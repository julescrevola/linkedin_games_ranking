import pandas as pd
import argparse

from linkedin_games_parser import parse_whatsapp_chat

# Path to input data
INPUT = "../data/input/_chat_fr.txt"
# Output CSV generated by the parser
PARSER_OUTPUT = "../data/output/games_leaderboard.csv"

# List of known games
GAMES = ["Tango", "Queens", "Mini Sudoku", "Zip"]


def run_parser():
    """Run the linkedin_games_parser.py script to update CSV."""
    try:
        df = parse_whatsapp_chat(INPUT)  # returns DataFrame with correct columns
        df.to_csv(PARSER_OUTPUT, index=False)
        return True
    except Exception as e:
        print(f"Error parsing chat: {e}")
        return False


def time_to_seconds(time_str):
    """Convert a time string mm:ss or hh:mm:ss to total seconds."""
    try:
        parts = [int(p) for p in time_str.strip().split(":")]
        if len(parts) == 2:
            return parts[0] * 60 + parts[1]
        elif len(parts) == 3:
            return parts[0] * 3600 + parts[1] * 60 + parts[2]
        else:
            return None
    except ValueError:
        return None


def compute_per_game_rankings(file_path, day=None):
    """
    Returns a dictionary of DataFrames, one per game, ranked from best (lowest time) to worst.
    Also includes average CEO percentage per player, ignoring NaN values.
    """
    df = pd.read_csv(file_path)
    df = df[df["sender"] != "X - Games (Nazionale di Zip)"]

    # Filter by day if provided
    if day:
        df = df[df["date"] == day]

    # Convert play_time to seconds
    df["time_sec"] = df["play_time"].astype(str).apply(time_to_seconds)

    # Convert CEO percentage to numeric
    df["ceo_percent"] = pd.to_numeric(df["ceo_percent"], errors="coerce")

    # Daily total time and normalized average
    # Sum total time per player per day
    daily_times = df.groupby(["date", "sender"], as_index=False)["time_sec"].sum()
    daily_times = daily_times.rename(
        columns={"sender": "Player", "time_sec": "Total Time (sec)"}
    )

    # Count total number of games played per player
    games_played = (
        df.groupby("sender", as_index=False)
        .size()
        .rename(columns={"size": "Games Played"})
    )
    games_played = games_played.rename(columns={"sender": "Player"})

    # Compute total time across all days per player
    total_time_all_days = daily_times.groupby("Player", as_index=False)[
        "Total Time (sec)"
    ].sum()

    # Merge with number of games played
    daily_avg_times = total_time_all_days.merge(games_played, on="Player", how="left")

    # Compute normalized average time (total_time / total_games)
    daily_avg_times["Average Time per Game (sec)"] = (
        daily_avg_times["Total Time (sec)"] / daily_avg_times["Games Played"]
    ).round(2)

    # Convert to mm:ss for readability
    daily_avg_times["Average Time per Game"] = daily_avg_times[
        "Average Time per Game (sec)"
    ].apply(lambda x: f"{int(x // 60)}:{int(x % 60):02d}")
    daily_avg_times["Total Time"] = daily_avg_times["Total Time (sec)"].apply(
        lambda x: f"{int(x // 3600)}:{int((x % 3600) // 60):02d}:{int(x % 60):02d}"
        if not day
        else f"{int(x // 60)}:{int(x % 60):02d}"
    )

    # Keep clean columns
    daily_avg_times = (
        daily_avg_times[
            ["Player", "Total Time", "Games Played", "Average Time per Game"]
        ]
        .sort_values(by="Average Time per Game")
        .reset_index(drop=True)
    )

    per_game_rankings = {}
    overall_best_sum = pd.DataFrame({"Player": df["sender"].unique()})
    total_score = pd.DataFrame({"Player": df["sender"].unique(), "Total Score": 0})

    for game in GAMES:
        game_df = df[df["game"].str.lower() == game.lower()].copy()
        if game_df.empty:
            continue

        # Update total score
        score_map = {1: 5, 2: 2, 3: 1}
        game_df["rank"] = game_df.groupby("date")["time_sec"].rank(method="min")
        game_df["score"] = game_df["rank"].map(score_map).fillna(0)
        score_sum = (
            game_df.groupby("sender", as_index=False)["score"]
            .sum()
            .rename(columns={"sender": "Player"})
            .fillna(0)
        )
        total_score = total_score.merge(score_sum, on="Player", how="left")
        total_score["Total Score"] = total_score["Total Score"] + total_score["score"]
        total_score = total_score.drop(columns=["score"])

        # For each date, find the player with the lowest time
        best_per_day = (
            game_df.loc[
                game_df.groupby("date")["time_sec"].idxmin(), ["date", "sender"]
            ]
            .groupby("sender")
            .size()
            .reset_index(name="num_best")
        )

        # Compute average CEO percentage per player
        ceo_avg = game_df.groupby("sender", as_index=False)["ceo_percent"].mean()

        # Compute avg times per player
        avg_times = game_df.groupby("sender", as_index=False)["time_sec"].mean()
        # Compute min times per player
        min_times = game_df.groupby("sender", as_index=False)["time_sec"].min()

        # Merge best times and CEO averages
        merged = (
            pd.merge(avg_times, ceo_avg, on="sender")
            .merge(min_times, on="sender", suffixes=("_avg", "_min"))
            .merge(best_per_day, on="sender", how="left")
            .fillna({"num_best": 0})
        )

        if day:
            # Sort by lowest time (best performance first)
            merged = merged.sort_values(by="time_sec_avg", ascending=True).reset_index(
                drop=True
            )
        else:
            # Sort by number of times best (highest first)
            merged = merged.sort_values(by="num_best", ascending=False).reset_index(
                drop=True
            )

        # Convert time back to mm:ss for nicer display
        merged["avg_play_time_mmss"] = merged["time_sec_avg"].apply(
            lambda x: f"{int(x // 60)}:{int(x % 60):02d}"
        )
        merged["min_play_time_mmss"] = merged["time_sec_min"].apply(
            lambda x: f"{int(x // 60)}:{int(x % 60):02d}"
        )
        # Round CEO percentage to 2 decimals
        merged["ceo_percent"] = merged["ceo_percent"].round(2)
        # Convert num_best to int
        merged["num_best"] = merged["num_best"].astype(int, errors="ignore")

        # Rename and keep only relevant columns
        merged = merged.rename(
            columns={
                "sender": "Player",
                "avg_play_time_mmss": "Average Time" if not day else "Time",
                "min_play_time_mmss": "Minimum Time",
                "ceo_percent": "Average CEO %" if not day else "CEO %",
                "num_best": "Times N°1" if not day else "N°1",
            }
        )

        if not day:
            per_game_rankings[game] = merged[
                [
                    "Player",
                    "Average Time",
                    "Minimum Time",
                    "Average CEO %",
                    "Times N°1",
                ]
            ]
        else:
            per_game_rankings[game] = merged[
                [
                    "Player",
                    "Time",
                    "CEO %",
                    "N°1",
                ]
            ]

        # Add dataframe combining all times number of best times
        overall_best_sum = (
            overall_best_sum.merge(
                merged[["Player", "Times N°1" if not day else "N°1"]],
                on="Player",
                how="left",
            )
            .fillna({"Times N°1" if not day else "N°1": 0})
            .rename(
                columns={
                    "Times N°1" if not day else "N°1": f"Times N°1 at {game}"
                    if not day
                    else f"N°1 at {game}"
                }
            )
        )

    # Sum num_best across all games for overall ranking
    overall_best_sum["Overall Times N°1"] = (
        overall_best_sum[
            [
                f"Times N°1 at {game}" if not day else f"N°1 at {game}"
                for game in GAMES
                if f"Times N°1 at {game}" in overall_best_sum.columns
                or f"N°1 at {game}" in overall_best_sum.columns
            ]
        ]
        .sum(axis=1)
        .astype(int, errors="ignore")
    )
    overall_best_sum = (
        overall_best_sum[["Player", "Overall Times N°1"]]
        .sort_values(by="Overall Times N°1", ascending=False)
        .reset_index(drop=True)
    )

    # Add overall summary to the dictionary
    per_game_rankings["N°1"] = overall_best_sum
    per_game_rankings["Average Time per Game"] = daily_avg_times
    # Order total score
    total_score = (
        total_score.sort_values(by="Total Score", ascending=False)
        .reset_index(drop=True)
        .fillna(0)
    )

    return per_game_rankings, total_score


def main(day=None):
    if not run_parser():
        return

    per_game_rankings, total_score = compute_per_game_rankings(PARSER_OUTPUT, day=day)

    print("\n=== Total Score Rankings ===")
    print(total_score)
    total_score.to_csv(
        f"../data/output/{day if day is not None else 'overall'}_total_score_rankings.csv",
        index=False,
    )

    for game, df in per_game_rankings.items():
        print(f"\n=== {game} Rankings ===")
        print(df)
        df.to_csv(
            f"../data/output/{day if day is not None else 'overall'}_{game.lower().replace(' ', '_')}_rankings.csv",
            index=False,
        )


if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(
        description="Per-game mini leaderboard with CEO percentages"
    )
    parser.add_argument(
        "-d",
        "--day",
        type=str,
        help="Specific day (YYYY-MM-DD) to filter results, or omit for all-time",
    )
    args = parser.parse_args()

    main(day=args.day)
