import pandas as pd
import re
import argparse

from linkedin_games_parser import parse_whatsapp_chat

# Path to input data
INPUT = "../data/input/_chat.txt"
# Output CSV generated by the parser
PARSER_OUTPUT = "../data/output/games_leaderboard.csv"

# List of known games
GAMES = ["Zip", "Tango", "Queens", "Mini Sudoku"]


def run_parser():
    """Run the linkedin_games_parser.py script to update CSV."""
    try:
        df = parse_whatsapp_chat(INPUT)  # returns DataFrame with correct columns
        # Hard code unsaved results for Samuele on 2025-10-17 for Queens
        # Regex pattern — case-insensitive search for 'samu'
        pattern = re.compile(r"samu", re.IGNORECASE)
        # Find name that matches
        match = [name for name in df["sender"].unique() if pattern.search(name)][
            0
        ].title()
        unsaved_data = pd.DataFrame(
            {
                "date": ["2025-10-17"],
                "game": ["Queens"],
                "sender": [match],
                "play_time": ["1:45"],
                "ceo_percent": None,
            }
        )
        df = pd.concat([df, unsaved_data], ignore_index=True)
        df.to_csv(PARSER_OUTPUT, index=False)
        return True
    except Exception as e:
        print(f"Error parsing chat: {e}")
        return False


def time_to_seconds(time_str):
    """Convert a time string mm:ss or hh:mm:ss to total seconds."""
    try:
        parts = [int(p) for p in time_str.strip().split(":")]
        if len(parts) == 2:
            return parts[0] * 60 + parts[1]
        elif len(parts) == 3:
            return parts[0] * 3600 + parts[1] * 60 + parts[2]
        else:
            return None
    except ValueError:
        return None


def compute_per_game_rankings(file_path, day=None):
    """
    Returns a dictionary of DataFrames, one per game, ranked from best (lowest time) to worst.
    Also includes average CEO percentage per player, ignoring NaN values.
    """
    df = pd.read_csv(file_path).drop_duplicates()
    df = df[df["sender"] != "X - Games (Nazionale di Zip)"]

    # Filter by day if provided
    if day:
        df = df[df["date"] == day]

    # Convert play_time to seconds
    df["time_sec"] = df["play_time"].astype(str).apply(time_to_seconds)

    # Convert CEO percentage to numeric
    df["ceo_percent"] = pd.to_numeric(df["ceo_percent"], errors="coerce")

    # Daily total time and normalized average
    # Sum total time per player per day
    daily_times = df.groupby(["date", "sender"], as_index=False)["time_sec"].sum()
    daily_times = daily_times.rename(
        columns={"sender": "Player", "time_sec": "Total Time (sec)"}
    )

    # Count total number of games played per player
    games_played = (
        df.groupby("sender", as_index=False)
        .size()
        .rename(columns={"size": "Games Played"})
    )
    games_played = games_played.rename(columns={"sender": "Player"})

    # Compute total time across all days per player
    total_time_all_days = daily_times.groupby("Player", as_index=False)[
        "Total Time (sec)"
    ].sum()

    # Merge with number of games played
    daily_avg_times = total_time_all_days.merge(games_played, on="Player", how="left")

    # Compute normalized average time (total_time / total_games)
    daily_avg_times["Average Time per Game (sec)"] = (
        daily_avg_times["Total Time (sec)"] / daily_avg_times["Games Played"]
    ).round(2)
    daily_avg_times["Total Time (sec)"] = daily_avg_times.apply(
        lambda row: row["Total Time (sec)"]
        if row["Games Played"] == daily_avg_times["Games Played"].max()
        else (daily_avg_times["Games Played"].max() - row["Games Played"])
        * row["Average Time per Game (sec)"]
        + row["Total Time (sec)"],
        axis=1,
    )

    # Convert to mm:ss for readability
    daily_avg_times["Average Time per Game"] = daily_avg_times[
        "Average Time per Game (sec)"
    ].apply(lambda x: f"{int(x // 60)}:{int(x % 60):02d}")
    daily_avg_times["Total Time"] = daily_avg_times["Total Time (sec)"].apply(
        lambda x: f"{int(x // 3600)}:{int((x % 3600) // 60):02d}:{int(x % 60):02d}"
        if not day
        else f"{int(x // 60)}:{int(x % 60):02d}"
    )

    # Keep clean columns
    final_daily_avg_times = (
        daily_avg_times[["Player", "Games Played", "Average Time per Game"]]
        .sort_values(by="Average Time per Game", ascending=True)
        .reset_index(drop=True)
    )
    final_daily_avg_times.index += 1

    final_total_times = (
        daily_avg_times[["Player", "Games Played", "Total Time"]]
        .sort_values(by="Total Time", ascending=True)
        .reset_index(drop=True)
    )
    final_total_times.index += 1

    # Compute variance for all games together
    variance_df = df.merge(
        df.groupby(["date", "sender"], as_index=False)["time_sec"].mean(),
        suffixes=("", "_avg"),
        on=["date", "sender"],
        how="left",
    )
    variance_df["mean_diff"] = abs(
        variance_df["time_sec"] - variance_df["time_sec_avg"]
    ).round(2)
    variance_summary = (
        variance_df.groupby("sender", as_index=False)["mean_diff"]
        .mean()
        .rename(columns={"sender": "Player", "mean_diff": "Variance"})
        .sort_values(by="Variance", ascending=True)
        .reset_index(drop=True)
    )
    variance_summary.index += 1

    per_game_rankings = {}
    overall_best_sum = pd.DataFrame({"Player": df["sender"].unique()})
    total_score = pd.DataFrame(
        {"Player": df["sender"].unique(), "Total Score": 0}
    ).merge(games_played, on="Player", how="left")

    for game in GAMES:
        game_df = df[df["game"].str.lower() == game.lower()]
        if game_df.empty:
            print(f"No data for game: {game}")
            continue

        # Rank players by time
        score_map = {1: 5, 2: 3, 3: 1}
        game_df["rank"] = game_df.groupby("date")["time_sec"].rank(method="min")
        game_df["score"] = game_df["rank"].map(score_map).fillna(0).astype(float)
        success_list = []
        for date in game_df["date"].unique():
            date_df = game_df[game_df["date"] == date]
            if date_df["score"].sum() != 9:
                dict_scores = date_df["score"].value_counts().to_dict().items()
                for key, val in dict_scores:
                    if key == 5 and val == 2:
                        game_df.loc[
                            (game_df["date"] == date) & (game_df["score"] == key),
                            "score",
                        ] = 4
                    elif key == 5 and val > 2:
                        game_df.loc[
                            (game_df["date"] == date) & (game_df["score"] == key),
                            "score",
                        ] = 9 / val
                    elif key == 3 and val > 1:
                        game_df.loc[
                            (game_df["date"] == date) & (game_df["score"] == key),
                            "score",
                        ] = 4 / val
                    elif key == 1 and val > 1:
                        game_df.loc[
                            (game_df["date"] == date) & (game_df["score"] == key),
                            "score",
                        ] = 1 / val
            if (
                (9 <= game_df[game_df["date"] == date]["score"].sum() <= 9.00001)
                or (
                    len(date_df) == 2
                    and game_df[game_df["date"] == date]["score"].sum() == 8
                )
                or (
                    len(date_df) == 1
                    and game_df[game_df["date"] == date]["score"].sum() == 5
                )
                or (date_df.empty)
            ):
                success_list.append(True)
        if len(success_list) == len(game_df["date"].unique()):
            print(f"Scores computed successfully for {game}!")

        # Update total score
        score_sum = (
            game_df.groupby("sender", as_index=False)["score"]
            .sum()
            .rename(columns={"sender": "Player"})
            .fillna(0)
        )
        total_score = total_score.merge(score_sum, on="Player", how="left")
        total_score["Total Score"] = total_score["Total Score"] + total_score["score"]
        total_score = total_score.drop(columns=["score"])

        # For each date, find the player with the lowest time
        best_per_day = (
            game_df.loc[
                game_df.groupby("date")["time_sec"].idxmin(), ["date", "sender"]
            ]
            .groupby("sender")
            .size()
            .reset_index(name="num_best")
        )

        # Compute average CEO percentage per player
        ceo_avg = game_df.groupby("sender", as_index=False)["ceo_percent"].mean()
        # Compute avg times per player
        avg_times = game_df.groupby("sender", as_index=False)["time_sec"].mean()
        # Compute min times per player
        min_times = game_df.groupby("sender", as_index=False)["time_sec"].min()
        # Compute total score per player
        score_sum_copy = (
            game_df.groupby("sender", as_index=False)["score"].sum().fillna(0)
        )

        # Merge best times and CEO averages
        merged = (
            pd.merge(avg_times, ceo_avg, on="sender")
            .merge(min_times, on="sender", suffixes=("_avg", "_min"))
            .merge(best_per_day, on="sender", how="left")
            .merge(score_sum_copy, on="sender", how="left")
            .fillna({"num_best": 0})
        )

        if day:
            # Sort by lowest time (best performance first)
            merged = merged.sort_values(by="time_sec_avg", ascending=True).reset_index(
                drop=True
            )
        else:
            # Sort by number of times best (highest first)
            merged = merged.sort_values(by="num_best", ascending=False).reset_index(
                drop=True
            )

        # Convert time back to mm:ss for nicer display
        merged["avg_play_time_mmss"] = merged["time_sec_avg"].apply(
            lambda x: f"{int(x // 60)}:{int(x % 60):02d}"
        )
        merged["min_play_time_mmss"] = merged["time_sec_min"].apply(
            lambda x: f"{int(x // 60)}:{int(x % 60):02d}"
        )
        # Round CEO percentage to 2 decimals
        merged["ceo_percent"] = merged["ceo_percent"].round(2)
        # Convert num_best to int
        merged["num_best"] = merged["num_best"].astype(int, errors="ignore")
        # Round score to 2 decimals
        merged["score"] = merged["score"].astype(float, errors="ignore").round(2)

        # Rename and keep only relevant columns
        merged = merged.rename(
            columns={
                "sender": "Player",
                "avg_play_time_mmss": "Average Time" if not day else "Time",
                "min_play_time_mmss": "Minimum Time",
                "ceo_percent": "Average CEO %" if not day else "CEO %",
                "num_best": "Times N°1" if not day else "N°1",
            }
        )

        if not day:
            merged_final = (
                merged[
                    [
                        "Player",
                        "Average Time",
                        "Minimum Time",
                        "Average CEO %",
                        "Times N°1",
                        "score",
                    ]
                ]
                .sort_values(by="Times N°1", ascending=False)
                .reset_index(drop=True)
                .rename(columns={"score": "Total Score"})
            )
            merged_final.index += 1
            per_game_rankings[game] = merged_final
        else:
            merged_final = (
                merged[["Player", "Time", "CEO %", "N°1", "score"]]
                .sort_values(by="Time", ascending=True)
                .reset_index(drop=True)
                .rename(columns={"score": "Score"})
            )
            merged_final.index += 1
            per_game_rankings[game] = merged_final

        # Add dataframe combining all times number of best times
        overall_best_sum = (
            overall_best_sum.merge(
                merged[["Player", "Times N°1" if not day else "N°1"]],
                on="Player",
                how="left",
            )
            .fillna({"Times N°1" if not day else "N°1": 0})
            .rename(
                columns={
                    "Times N°1" if not day else "N°1": f"Times N°1 at {game}"
                    if not day
                    else f"N°1 at {game}"
                }
            )
        )

    # Sum num_best across all games for overall ranking
    overall_best_sum["Overall Times N°1"] = (
        overall_best_sum[
            [
                f"Times N°1 at {game}" if not day else f"N°1 at {game}"
                for game in GAMES
                if f"Times N°1 at {game}" in overall_best_sum.columns
                or f"N°1 at {game}" in overall_best_sum.columns
            ]
        ]
        .sum(axis=1)
        .astype(int, errors="ignore")
    )
    col_overall = overall_best_sum.pop("Overall Times N°1")
    overall_best_sum.insert(1, "Overall Times N°1", col_overall)
    overall_best_sum = overall_best_sum.sort_values(
        by="Overall Times N°1", ascending=False
    ).reset_index(drop=True)
    overall_best_sum.index += 1

    # Order total score
    col_games_played = total_score.pop("Games Played")
    total_score.insert(1, "Games Played", col_games_played)
    total_score["Total Score"] = total_score["Total Score"].round(2)
    total_score = (
        total_score.sort_values(by="Total Score", ascending=False)
        .reset_index(drop=True)
        .fillna(0)
    )
    total_score.index += 1

    return (
        per_game_rankings,
        total_score,
        final_total_times,
        final_daily_avg_times,
        variance_summary,
        overall_best_sum,
    )


def main(day=None):
    if not run_parser():
        return

    (
        per_game_rankings,
        total_score,
        final_total_times,
        final_daily_avg_times,
        variance_summary,
        overall_best_sum,
    ) = compute_per_game_rankings(PARSER_OUTPUT, day=day)
    # Total score
    print("\n=== Total Score Rankings ===")
    print(total_score)
    total_score.to_csv(
        f"../data/output/{day if day is not None else 'overall'}_total_score_rankings.csv",
        index=False,
    )
    # Total times
    print("\n=== Total Times Rankings ===")
    print(final_total_times)
    final_total_times.to_csv(
        f"../data/output/{day if day is not None else 'overall'}_total_times_rankings.csv",
        index=False,
    )
    # Average times
    print("\n=== Average Times per Game Rankings ===")
    print(final_daily_avg_times)
    final_daily_avg_times.to_csv(
        f"../data/output/{day if day is not None else 'overall'}_average_times_rankings.csv",
        index=False,
    )
    # Overall times N°1
    print("\n=== Overall Times N°1 Rankings ===")
    print(overall_best_sum)
    overall_best_sum.to_csv(
        f"../data/output/{day if day is not None else 'overall'}_overall_times_n1_rankings.csv",
        index=False,
    )
    # Overall Variance
    print("\n=== Overall Variance Rankings ===")
    print(variance_summary)
    variance_summary.to_csv(
        f"../data/output/{day if day is not None else 'overall'}_overall_variance_rankings.csv",
        index=False,
    )
    # Per game rankings
    for game, df in per_game_rankings.items():
        print(f"\n=== {game} Rankings ===")
        print(df)
        df.to_csv(
            f"../data/output/{day if day is not None else 'overall'}_{game.lower().replace(' ', '_')}_rankings.csv",
            index=False,
        )


if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(
        description="Per-game mini leaderboard with CEO percentages"
    )
    parser.add_argument(
        "-d",
        "--day",
        type=str,
        help="Specific day (YYYY-MM-DD) to filter results, or omit for all-time",
    )
    args = parser.parse_args()

    main(day=args.day)
